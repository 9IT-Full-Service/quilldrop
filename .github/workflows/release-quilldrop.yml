name: build-and-release

on:
  # push:
  #   branches: [main]
  workflow_dispatch:
    # tags:
    #   - 'v*' # z.B. v1.2.3

permissions:
  contents: write
  packages: write
  id-token: write
  issues: write
  pull-requests: write

env:
  # Hier kannst du einen Default-Name definieren, der in die Artefakte wandert
  APP_VERSION: ${{ github.ref_name }}
  GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}
  TARGET_REPO: owner/target-repo
  TAG: ${{ github.ref_name }}
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}-2

jobs:

  # Job 1: Automatisches Semver Tagging
  # create-version-tag:
  #   name: Create Version Tag
  #   # runs-on: ubuntu-latest
  #   # runs-on: [self-hosted, macbook]
  #   runs-on: [self-hosted]
  #   outputs:
  #     new_tag: ${{ steps.tag_version.outputs.new_tag }}
  #     changelog: ${{ steps.tag_version.outputs.changelog }}
  #   permissions:
  #     contents: write
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v6
  #       with:
  #         fetch-depth: 0

  #     - name: Bump version and push tag
  #       id: tag_version
  #       uses: mathieudutour/github-tag-action@v6.2
  #       with:
  #         github_token: ${{ secrets.GITHUB_TOKEN }}
  #         default_bump: patch
  #         release_branches: main
  #         # fix: = patch (0.0.1)
  #         # feat: = minor (0.1.0)
  #         # BREAKING CHANGE: = major (1.0.0)

  #     - name: Show new version
  #       run: |
  #         echo "New version: ${{ steps.tag_version.outputs.new_tag }}"
  #         echo "Changelog: ${{ steps.tag_version.outputs.changelog }}"

  create-version-tag:
    uses: 9it-full-service/shared-workflows/.github/workflows/prepare.yml@main
    with:
      version_override: ${{ github.event.inputs.version || '' }}
      default_version: 'dev'

  build:
    runs-on: [ arc-runner-set ]
    # runs-on: [ self-hosted ]
    needs: [ "create-version-tag" ]
    strategy:
      fail-fast: false
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: amd64

    steps:
      - uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.25'
          cache: true

      # - name: Print build matrix
      #   run: |
      #     echo "GOOS=${{ matrix.goos }}"
      #     echo "GOARCH=${{ matrix.goarch }}"
      #     echo "TAG=${{ github.ref_name }}"

      - name: Set build timestamp
        id: timestamp
        run: echo "BUILD_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Print build matrix
        run: |
          echo "GOOS=${{ matrix.goos }}"
          echo "GOARCH=${{ matrix.goarch }}"
          echo "TAG=${{ needs.create-version-tag.outputs.version }}"
          echo "VERSION=${{ needs.create-version-tag.outputs.version }}"
          echo "COMMIT=${{ github.sha }}"
          echo "BUILD_TIMESTAMP=${{ steps.timestamp.outputs.BUILD_TIMESTAMP }}"

      - name: Build quilldrop
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION: ${{ needs.create-version-tag.outputs.version }}
          COMMIT: ${{ github.sha }}
          BUILD_TIMESTAMP: ${{ steps.timestamp.outputs.BUILD_TIMESTAMP }}
        run: |
          set -euo pipefail
          mkdir -p dist
          BIN_NAME="quilldrop-${GOOS}-${GOARCH}"
          OUT="dist/${BIN_NAME}"
          # Windows: .exe
          if [ "${GOOS}" = "windows" ]; then OUT="${OUT}.exe"; fi
          # Build (im Unterordner)
          (cd . && CGO_ENABLED=0 go build -trimpath -ldflags="-s -w \
          -X 'main.version=${VERSION}' \
          -X 'main.commit=${COMMIT}' \
          -X 'main.date=${BUILD_TIMESTAMP}'" -o "${OUT}")
          # go mod init quilldrop && go mod tidy && \
          go mod tidy && \
          # CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo \
          # -ldflags="-s -w \
          #   -X 'main.version=${VERSION}' \
          #   -X 'main.commit=${COMMIT}' \
          #   -X 'main.date=${BUILD_TIMESTAMP}'" \
          # -o vm-tracker-api main.go
          # Paket
          if [[ "${OUT}" == *.exe ]]; then
            (cd dist && zip "${BIN_NAME}.zip" "${BIN_NAME}.exe")
          else
            (cd dist && tar -czf "${BIN_NAME}.tar.gz" "${BIN_NAME}")
          fi

      # - name: Build vm-tracker-client
      #   env:
      #     GOOS: ${{ matrix.goos }}
      #     GOARCH: ${{ matrix.goarch }}
      #     VERSION: ${{ needs.create-version-tag.outputs.version }}  # â† hinzufÃ¼gen
      #     COMMIT: ${{ github.sha }}                                  # â† hinzufÃ¼gen
      #     # BUILD_TIMESTAMP: ${{ github.event.head_commit.timestamp }}
      #     BUILD_TIMESTAMP: $(date -u +%Y-%m-%dT%H:%M:%SZ)
      #   run: |
      #     set -euo pipefail
      #     mkdir -p dist
      #     BIN_NAME="quilldrop-${GOOS}-${GOARCH}"
      #     OUT="dist/${BIN_NAME}"
      #     if [ "${GOOS}" = "windows" ]; then OUT="${OUT}.exe"; fi
      #     (cd . && CGO_ENABLED=0 go build -trimpath -ldflags="-s -w \
      #     -X 'main.version=${VERSION}' \
      #     -X 'main.commit=${COMMIT}' \
      #     -X 'main.date=${BUILD_TIMESTAMP}'" -o "../${OUT}")
      #     if [[ "${OUT}" == *.exe ]]; then
      #       (cd dist && zip "${BIN_NAME}.zip" "${BIN_NAME}.exe")
      #     else
      #       (cd dist && tar -czf "${BIN_NAME}.tar.gz" "${BIN_NAME}")
      #     fi

      - name: Checksums erzeugen
        run: |
          set -euo pipefail
          cd dist
          # Ein Checksum-File pro Matrix-Kombination
          # FILE="CHECKSUMS-${{ env.APP_VERSION }}-${{ matrix.goos }}-${{ matrix.goarch }}.txt"
          FILE="CHECKSUMS-${{ needs.create-version-tag.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}.txt"
          shopt -s nullglob
          for f in *.tar.gz *.zip; do
            sha256sum "$f" >> "$FILE"
          done
          cat "$FILE"

      - name: Upload artifacts (unique per matrix)
        uses: actions/upload-artifact@v5
        with:
          name: release-bundles-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.run_attempt }}
          path: |
            dist/*.tar.gz
            dist/*.zip
            dist/CHECKSUMS-*.txt
          if-no-files-found: error
          compression-level: 6

  release:
    needs: [ "build", "create-version-tag" ]
    runs-on: arc-runner-set
    # runs-on: [ self-hosted ]
    steps:
      - name: Download all build artifacts (merged)
        uses: actions/download-artifact@v6
        with:
          pattern: release-bundles-*
          merge-multiple: true
          path: dist

      - name: Ãœbersicht
        run: ls -la dist

      # --- Option A: Release in anderes Repo via gh CLI ---
      - name: Create release in target repo
        env:
          GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}   # ðŸ‘ˆ wichtig: GH_TOKEN, nicht RELEASE_TOKEN
          TARGET_REPO: 9it-full-service/quilldrop
          TAG: ${{ needs.create-version-tag.outputs.version }}
          # TAG: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          gh release create "$TAG" \
            --repo "$TARGET_REPO" \
            --title "$TAG" \
            --notes "Automated release from ${GITHUB_REPOSITORY}@${GITHUB_SHA}" \
          || echo "Release exists, continue to upload assets."

          gh release upload "$TAG" dist/* --repo "$TARGET_REPO" --clobber

  # build-and-push-docker:
  #   name: Build Multi-arch Docker
  #   needs: [create-version-tag, build]
  #   runs-on: [self-hosted]
  #   permissions:
  #     contents: read
  #     packages: write
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v6

  #     # Alle Artifacts herunterladen
  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v6
  #       with:
  #         path: ./artifacts

  #     # Ãœbersicht was heruntergeladen wurde
  #     - name: List downloaded artifacts
  #       run: |
  #         echo "=== Downloaded artifacts ==="
  #         ls -laR artifacts/

  #     # Binaries fÃ¼r Docker vorbereiten
  #     - name: Prepare binaries for Docker
  #       run: |
  #         set -euo pipefail
  #         mkdir -p docker-bin/{amd64,arm64}
          
  #         # Suche und extrahiere amd64 binary
  #         echo "Searching for amd64 binary..."
  #         AMD64_TAR=$(find artifacts -name "vm-tracker-api-linux-amd64.tar.gz" -type f | head -1)
  #         if [ -n "$AMD64_TAR" ]; then
  #           echo "Found: $AMD64_TAR"
  #           tar -xzf "$AMD64_TAR" -C docker-bin/amd64/
  #           mv docker-bin/amd64/vm-tracker-api-linux-amd64 docker-bin/amd64/vm-tracker-api
  #           chmod +x docker-bin/amd64/vm-tracker-api
  #         else
  #           echo "ERROR: amd64 binary not found!"
  #           exit 1
  #         fi
          
  #         # Suche und extrahiere arm64 binary
  #         echo "Searching for arm64 binary..."
  #         ARM64_TAR=$(find artifacts -name "vm-tracker-api-linux-arm64.tar.gz" -type f | head -1)
  #         if [ -n "$ARM64_TAR" ]; then
  #           echo "Found: $ARM64_TAR"
  #           tar -xzf "$ARM64_TAR" -C docker-bin/arm64/
  #           mv docker-bin/arm64/vm-tracker-api-linux-arm64 docker-bin/arm64/vm-tracker-api
  #           chmod +x docker-bin/arm64/vm-tracker-api
  #         else
  #           echo "ERROR: arm64 binary not found!"
  #           exit 1
  #         fi
          
  #         echo "=== Prepared binaries ==="
  #         ls -la docker-bin/*/
  #         file docker-bin/*/vm-tracker-api

  #     - name: Set up QEMU
  #       uses: docker/setup-qemu-action@v3

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: Log in to Container Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ${{ env.REGISTRY }}
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Set build metadata
  #       id: meta
  #       run: |
  #         echo "VERSION=${{ needs.create-version-tag.outputs.new_tag }}" >> $GITHUB_ENV
  #         echo "COMMIT=${GITHUB_SHA}" >> $GITHUB_ENV
  #         echo "BUILD_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

  #     - name: Build and push Docker image
  #       uses: docker/build-push-action@v6
  #       with:
  #         context: .
  #         platforms: linux/amd64,linux/arm64
  #         push: true
  #         tags: |
  #           ghcr.io/9it-full-service/vm-tracker-api:${{ needs.create-version-tag.outputs.new_tag }}
  #           ghcr.io/9it-full-service/vm-tracker-api:latest
  #         labels: |
  #           org.opencontainers.image.version=${{ needs.create-version-tag.outputs.new_tag }}
  #           org.opencontainers.image.created=${{ env.BUILD_TIMESTAMP }}
  #           org.opencontainers.image.revision=${{ github.sha }}
  #         build-args: |
  #           VERSION=${{ env.VERSION }}
  #           COMMIT=${{ env.COMMIT }}
  #           BUILD_TIMESTAMP=${{ env.BUILD_TIMESTAMP }}
  #         # cache-from: type=gha
  #         # cache-to: type=gha,mode=max
  #         provenance: false

  #     # - name: Clean up Docker images
  #     #   if: always()  # Also run in case of errors
  #     #   run: |
  #     #     # remove dangling images
  #     #     docker rmi ghcr.io/9it-full-service/vm-tracker-api:${{ needs.create-version-tag.outputs.new_tag }}
  #     #     docker rmi ghcr.io/9it-full-service/vm-tracker-api:latest
  #     #     # docker image prune -f

